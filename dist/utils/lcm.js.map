{"version":3,"sources":["../../src/utils/lcm.js"],"names":["gcd","a","b","lcm","inverseMod","n","t","newt","r","newr","quotient","Math","floor","oldt","oldr","NaN","calcCoprime","totient","listOfCoprimes","i","push","random","length"],"mappings":";;;;;AAAA;;;;;AAKA,IAAMA,MAAM,SAANA,GAAM,CAACC,CAAD,EAAIC,CAAJ,EAAU;AAClB,MAAIA,MAAM,CAAV,EAAa,OAAOD,CAAP;AACb,SAAOD,IAAIE,CAAJ,EAAOD,IAAIC,CAAX,CAAP;AACH,CAHD;;AAMA;;;;;AAKA,IAAMC,MAAM,SAANA,GAAM,CAACF,CAAD,EAAIC,CAAJ,EAAU;AAClB,SAAQD,IAAIC,CAAL,GAAQF,IAAIC,CAAJ,EAAOC,CAAP,CAAf;AACH,CAFD;;AAIA;;;;;;;AAOA,IAAME,aAAa,SAAbA,UAAa,CAACH,CAAD,EAAII,CAAJ,EAAU;AACzB,MAAIJ,IAAI,CAAR,EAAW;AACTA,QAAKA,IAAII,CAAL,GAAUA,CAAd;AACD;;AAED,MAAIC,IAAI,CAAR;AACA,MAAIC,OAAO,CAAX;AACA,MAAIC,IAAIH,CAAR;AACA,MAAII,OAAOR,CAAX;;AAEA,SAAMQ,SAAS,CAAf,EAAkB;AAChB,QAAIC,WAAWC,KAAKC,KAAL,CAAWJ,IAAEC,IAAb,CAAf;AACA,QAAII,OAAOP,CAAX;AACAA,QAAIC,IAAJ;AACAA,WAAOM,OAAOH,WAAWH,IAAzB;;AAEA,QAAIO,OAAON,CAAX;AACAA,QAAIC,IAAJ;AACAA,WAAOK,OAAOJ,WAAWD,IAAzB;AACD;;AAED,MAAGD,IAAI,CAAP,EAAU;AAAE,WAAOO,GAAP;AAAY;;AAExB,SAAQT,IAAI,CAAL,GAAUA,CAAV,GAAeA,IAAED,CAAxB;AACD,CAxBH;;AA0BA;;;;;;AAMA,IAAMW,cAAc,SAAdA,WAAc,CAACf,CAAD,EAAIgB,OAAJ,EAAgB;AAChC,MAAIC,iBAAiB,EAArB;AACA,OAAK,IAAIC,IAAIlB,CAAb,EAAgBkB,IAAIF,OAApB,EAA6BE,GAA7B,EAAkC;AAC9B,QAAKnB,IAAImB,CAAJ,EAAOF,OAAP,MAAoB,CAAzB,EAA8BC,eAAeE,IAAf,CAAoBD,CAApB;AACjC;AACD,SAAOD,eAAeP,KAAKC,KAAL,CAAWD,KAAKU,MAAL,KAAgBH,eAAeI,MAA1C,CAAf,CAAP;AACH,CAND;;QASItB,G,GAAAA,G;QACAG,G,GAAAA,G;QACAC,U,GAAAA,U;QACAY,W,GAAAA,W","file":"lcm.js","sourcesContent":["/**\n * Uses Euclidean algorithm to compute Greatest Common Divisor \n * @param {number} a \n * @param {number} b \n */\nconst gcd = (a, b) => {\n    if (b === 0) return a\n    return gcd(b, a % b)\n}\n\n\n/**\n * Generates Lowest Common Multiple\n * @param {number} a \n * @param {number} b \n */\nconst lcm = (a, b) => {\n    return (a * b)/gcd(a, b)\n}\n\n/**\n * For now, copied from this example\n * Credit https://github.com/rsandor/number-theory/blob/master/lib/inverse_mod.js\n * and https://en.wikipedia.org/wiki/Modular_multiplicative_inverse#Computation\n * @param {*} a \n * @param {*} n \n */\nconst inverseMod = (a, n) => {\n    if (a < 0) {\n      a = (a % n) + n;\n    }\n  \n    var t = 0;\n    var newt = 1;\n    var r = n;\n    var newr = a;\n  \n    while(newr !== 0) {\n      var quotient = Math.floor(r/newr);\n      var oldt = t;\n      t = newt;\n      newt = oldt - quotient * newt;\n  \n      var oldr = r;\n      r = newr;\n      newr = oldr - quotient * newr;\n    }\n  \n    if(r > 1) { return NaN };\n  \n    return (t > 0) ? t : (t+n);\n  };\n\n/**\n * Calculates all the coprimes between the starting number, a, and the totient, the given prime\n * Because in this example there are a finite number of coprimes - we can just generate them all and pick one randomly\n * @param {number} a \n * @param {number} totient \n */\nconst calcCoprime = (a, totient) => {\n    let listOfCoprimes = []\n    for (let i = a; i < totient; i++) {\n        if ((gcd(i, totient) === 1))  listOfCoprimes.push(i)\n    }\n    return listOfCoprimes[Math.floor(Math.random() * listOfCoprimes.length)]\n}\n\nexport {\n    gcd,\n    lcm,\n    inverseMod,\n    calcCoprime\n}"]}